package com.example.demo.algorithm;

/**
 * @author : coder
 * @create 2021/1/10 16:39
 */
public class Kmp {

    /**
     * 求出一个字符数组的next数组
     *
     * @param t 字符数组
     * @return next数组
     */
    public static int[] getNextArray(char[] t) {
        int[] next = new int[t.length];
        next[0] = -1;
        next[1] = 0;
        int k;
        for (int j = 2; j < t.length; j++) {
            k = next[j - 1];
            while (k != -1) {
                if (t[j - 1] == t[k]) {
                    next[j] = k + 1;
                    break;
                } else {
                    k = next[k];
                }
                //当k==-1跳出循环时，next[j]=0,否则next[j]会在break之前被赋值
                next[j] = 0;
            }
        }
        return next;
    }


    /**
     * 对主串s和模式串t进行KMP模式匹配
     *
     * @param s 主串
     * @param t 模式串
     * @return 若匹配成功，返回t在s中的位置（第一个相同字符对应的位置），若匹配失败，返回-1
     */
    public static int kmpMatch(String s, String t) {
        char[] sArr = s.toCharArray();
        char[] tArr = t.toCharArray();
        int[] next = getNextArray(tArr);
        int i = 0, j = 0;
        while (i < sArr.length && j < tArr.length) {
            if (j == -1 || sArr[i] == tArr[j]) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }
        if (j == tArr.length) {
            return i - j;
        } else {
            return -1;
        }
    }

    public static void main(String[] args) {
        System.out.println(kmpMatch("abcabaabaabcacb", "abaabcac"));
    }

}

/**
 * 在上面的例子中，我们可以看到，当i=8，j=5时，S[8]与T[5]不相等，于是置i=4，j=0，相当于将模式串向右移动一位，再开始下一趟匹配。然而，通过观察我们可以发现，之后的两趟匹配，即i=4，j=0以及i=5，j=0都是不必要的。这是因为，在之前的一趟匹配过程中，我们已经部分匹配了T的子串“abaab”。此时将T向右移动一位，则相当于对T中的“abaab……”与S中的“baab……”进行匹配，显然无法匹配成功。继续右移T，则相当于对T中的“abaab……”与S中的“aab……”进行匹配，依然无法匹配成功。只有当T向右移动3位后，此时对T中的“abaab……”与S中的“ab……”进行匹配，才会有成功的可能，也就有必要向后继续进行比较。如图2.1。
 *
 * ![图2.1](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107202953821-445138636.png)
 * 图2.1 匹配失败时，将T向右移动3位后，才有继续比较的必要
 * 因此，当i=8，j=5，T的子串“abaab”已经匹配成功，而其后一位字符却不相等时，不必回溯i指针，置i=8，j=2，继续向后比较，相当于将T向右移动3位，并从T的第3位开始向后比较。如图2.2。
 * ![图2.2](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203048317-1520055718.png)
 * 图2.2 匹配失败后，直接置i=8，j=2，继续向后比较
 * 这就是KMP算法的基本思路。对于模式串T中的前j个字符组成的子串，设置数组next[j]存放一个值，当模式串T匹配至第j个字符时与主串不相等，则i指针不变，将j指针置为next[j]的值，然后继续进行比较。在上例中，串“abaab”为模式串T的前5个字符组成的子串，令next[5]=2，当i=8，j=5时，S[8]与T[5]不相等，于是置i=8，j=next[j]=next[5]=2，然后继续进行比较。
 *
 * 因此，KMP算法的核心在于求出数组next，即模式串T中每一个长度为j (0<j<T.length) 的前缀所对应的next[j]的值。
 *
 * next数组求解算法
 * 在求解next数组前，我们首先需要理解next数组的含义。回到前面的例子，当T的子串“abaab”的下一个字符与主串不相等时，主串的指针i不变，j回溯至2，指向T的第3个字符，其本质是因为串“abaab”的前缀和后缀有一个长度为2的最长公共串“ab”，因此我们省略了前缀“ab”和后缀“ab”的比较过程，直接对它们的后一个字符，即T[2]和S[8]进行比较。
 *
 * 再看另一个例子，假设有模式串T=“abacaabadad”，其已部分匹配完T[0...7]，即“abacaaba”，在匹配T[8]时遇到匹配失败，因T[0...7]的前缀和后缀有长度为3的最长公共串“aba”，因此next[8]=3，置j=next[j]=next[8]=3，i不变，然后从T[3]，即T的第4个字符开始比较。如图2.3。
 *
 * ![图2.3](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203117367-612235735.png)
 * 图2.3 匹配T[8]时失败，i不变，j回溯至3
 * 总之，对于模式串T，next[j]代表了T的前j个字符组成的子串中，其前缀和后缀的最长公共串的长度。
 *
 * 求解字符串T的next数组的算法如下：
 *
 * next[0]=-1, next[1]=0。
 * 在求解next[j]时，令k=next[j-1]，
 * 比较T[j-1]与T[k]的值，
 * a. 若T[j-1]等于T[k]，则next[j]=k+1。
 * b. 若T[j-1]不等于T[k]，令k=next[k]，若k等于-1，则next[j]=0，否则跳至3。
 *
 * 下面以模式串T=“abaabcac”为例，给出求next数组的过程：
 *
 * next[0]=-1, next[1]=0。
 * 当j=2时，k=next[j-1]=next[1]=0，由于T[j-1]=T[1]=‘b’，T[k]=T[0]=‘a’，T[j-1]不等于T[k]，令k=next[k]=next[0]=-1，因此next[2]=0。
 * 当j=3时，k=next[j-1]=next[2]=0，由于T[j-1]=T[2]=‘a’，T[k]=T[0]=‘a’，T[j-1]等于T[k]，因此next[3]=k+1=1。
 * 当j=4时，k=next[j-1]=next[3]=1，由于T[j-1]=T[3]=‘a’，T[k]=T[1]=‘b’，T[j-1]不等于T[k]，令k=next[k]=next[1]=0。此时T[k]=T[0]=‘a’，T[j-1]等于T[k]，因此next[4]=k+1=1。
 * 当j=5时，k=next[j-1]=next[4]=1，由于T[j-1]=T[4]=‘b’，T[k]=T[1]=‘b’，T[j-1]等于T[k]，因此next[5]=k+1=2。
 * 当j=6时，k=next[j-1]=next[5]=2，由于T[j-1]=T[5]=‘c’，T[k]=T[2]=‘a’，T[j-1]不等于T[k]，令k=next[k]=next[2]=0。此时T[k]=T[0]=‘a’，T[j-1]不等于T[k]，再令k=next[k]=next[0]=-1，因此next[6]=0。
 * 当j=7时，k=next[j-1]=next[6]=0，由于T[j-1]=T[6]=‘a’，T[k]=T[0]=‘a’，T[j-1]等于T[k]，因此next[7]=k+1=1。
 * 将next数组全部求出之后，只需在简单的匹配算法上稍作修改，便得到了KMP的匹配算法：当模式串T匹配至第j个字符时匹配失败，i指针不变，将j指针置为next[j]的值，若j的值为-1，则将i和j同时加1。随后继续进行逐个的比较。
 *
 * 下面以模式串T=“abaabcac”和主串S=“abcabaabaabcacb”进行匹配为例，给出KMP匹配算法的全过程。
 * 之前已经求得模式串T的next数组为[-1, 0, 0, 1, 1, 2, 0, 1]。
 *
 * 初始时，i=0，j=0，匹配成功。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203144421-1790051929.png)
 * 2. i=1，j=1，匹配成功。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203301705-1573255069.png)
 * 3. i=2，j=2，匹配失败。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203312482-506404756.png)
 * 4. i=2，j=next[2]=0，匹配失败。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203321486-1584379594.png)
 * 5. i=2，j=next[0]=-1，匹配失败。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203329813-1181552146.png)
 * 6. i=2+1=3，j=-1+1=0，匹配成功。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203345507-1570749968.png)
 * 7. i=4，j=1，匹配成功。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203356011-1340913809.png)
 * 8. i=5，j=2，匹配成功。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203406410-1127902417.png)
 * 9. i=6，j=3，匹配成功。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203417066-1414119806.png)
 * 10. i=7，j=4，匹配成功。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203426091-1146892290.png)
 * 11. i=8，j=5，匹配失败。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203437862-1315035527.png)
 * 12. i=8，j=next[5]=2，匹配成功。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203448412-1574307342.png)
 * 13. 继续向后比较，中间过程均匹配成功，故不再赘述，当i=13，j=7时，模式串匹配完成。
 * ![](https://img2018.cnblogs.com/blog/1485189/201811/1485189-20181107203458300-1121595444.png)
 * 以上就是KMP匹配算法的全过程。总结一下，KMP算法的实质就是以空间换时间，在匹配之前将模式串的一些信息存储起来（next数组），在随后的匹配过程中利用这些信息减少不必要的匹配次数，以提高匹配效率。在实际的应用过程中，简单模式匹配算法的执行时间常常接近于KMP算法，仅当主串与模式串有很多“部分匹配”时，KMP算法才能显著提升性能。
 */
